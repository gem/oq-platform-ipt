/*
   Copyright (c) 2015-2016, GEM Foundation.

      This program is free software: you can redistribute it and/or modify
      it under the terms of the GNU Affero General Public License as
      published by the Free Software Foundation, either version 3 of the
      License, or (at your option) any later version.

      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU Affero General Public License for more details.

      You should have received a copy of the GNU Affero General Public License
      along with this program.  If not, see <https://www.gnu.org/licenses/agpl.html>.
*/

var vf_obj = {
    pfx: 'div.vf_gid ',
    o: $('div.vf_gid'),
    tbl: {},
    tbl_idx: 0,
    nrml: "",

    ctx: {
        functionId: null,
        assetCategory: null,
        lossCategory: null,
        functionDescription: null,
        tables: null
    },

    ctx_function_prob_mass_get: function(idx, scope) {
        var ret = {'type': 'prob_mass'};
        ret['id'] = $(scope).find('input[type="text"][name="id"]').val();
        ret['imt'] = $(scope).find('input[type="text"][name="imt"]').val();
        ret['imls'] = $(scope).find('input[type="text"][name="imls"]').val();
        ret['table'] = vf_obj.o.find('[name="tableDiv' + (idx + 1) + '"]').handsontable("getInstance").getData();

        return ret;
    },

    ctx_function_discr_get: function(idx, scope) {
        var ret = {'type': 'discr'};
        ret['id'] = $(scope).find('input[type="text"][name="id"]').val();
        ret['imt'] = $(scope).find('input[type="text"][name="imt"]').val();
        ret['distribution_select'] = $(scope).find('select[name="distribution_select"]').val();
        ret['table'] = vf_obj.o.find('[name="tableDiv' + (idx + 1) + '"]').handsontable("getInstance").getData();

        return ret;
    },

    ctx_tables_get: function(obj) {
        var ret = [];
        var $funcs = obj.o.find('.tables_gid');

        for (var i = 0 ; i < $funcs.length ; i++) {
            var ty = $($funcs[i]).attr('data-gem-func-type');
            if (ty == 'prob_mass') {
                ret.push(obj.ctx_function_prob_mass_get(i, $funcs[i]));
            }
            else if (ty == 'discr') {
                ret.push(obj.ctx_function_discr_get(i, $funcs[i]));
            }
            else {
                console.log("Vulnerability function type [" + ty + "] not recognized");
            }
        }
        return ret;
    },
    
    ctx_get: function (obj) {
        var ctx = obj.ctx;

        ctx.functionId = obj.o.find('input#functionId').val();
        ctx.assetCategory = obj.o.find('input#assetCategory').val();
        ctx.lossCategory = obj.o.find('select#lossCategory').val();
        ctx.functionDescription = obj.o.find('textarea#functionDescription').val();
        ctx.limitStates = obj.o.find('textarea#limitStates').val();
        ctx.tables = obj.ctx_tables_get(obj);
    },

    ctx_save: function (obj) {
        if (window.localStorage == undefined) {
            return false;
        }
        obj.ctx_get(obj);
        var ser = JSON.stringify(obj.ctx);
        window.localStorage.setItem('gem_ipt_vulnerability', ser);
        console.log(ser);
    },

    ctx_load_func_prob_mass_step_gen: function (obj, load_step, load_funcs_step, step_cur, ctx)
    {
        function ctx_load_func_discr_step()
        {
            var changed = false;
            var table = ctx.tables[load_funcs_step];

            while (changed == false) {
                switch(step_cur) {
                case 0:
                    obj.o.find('button#addProbMassFunc').click();
                    changed = true;
                    break;
                case 1:
                    obj.o.find('div.tables_gid:last input[type="text"][name="id"]').val(table['id']).change();
                    changed = true;
                    break;
                case 2:
                    obj.o.find('div.tables_gid:last input[type="text"][name="imt"]').val(table['imt']).change();
                    changed = true;
                    break;
                case 3:
                    obj.o.find('div.tables_gid:last input[type="text"][name="imls"]').val(table['imls']).change();
                    changed = true;
                    break;
                case 4:
                    var htable = obj.o.find('div.tables_gid:last div[name^="tableDiv"]').handsontable("getInstance");
                    htable.loadData(table.table);

                    changed = true;
                    break;
                default:
                    var ctx_load_funcs_step = obj.ctx_load_funcs_step_gen(
                        obj, load_step, load_funcs_step + 1, ctx);
                    ctx_load_funcs_step();
                    return;
                    break;
                }

                step_cur++;
            }
            setTimeout(ctx_load_func_discr_step, 0);
        }

        return ctx_load_func_discr_step;
    },
    
    ctx_load_func_discr_step_gen: function (obj, load_step, load_funcs_step, step_cur, ctx)
    {
        function ctx_load_func_discr_step()
        {
            var changed = false;
            var table = ctx.tables[load_funcs_step];

            while (changed == false) {
                switch(step_cur) {
                case 0:
                    obj.o.find('button#addDiscreteFunc').click();
                    changed = true;
                    break;
                case 1:
                    obj.o.find('div.tables_gid:last input[type="text"][name="id"]').val(table['id']).change();
                    changed = true;
                    break;
                case 2:
                    obj.o.find('div.tables_gid:last input[type="text"][name="imt"]').val(table['imt']).change();
                    changed = true;
                    break;
                case 3:
                    obj.o.find('div.tables_gid:last select[name="distribution_select"]').val(table['distribution_select']).change();
                    changed = true;
                    break;
                case 4:
                    var htable = obj.o.find('div.tables_gid:last div[name^="tableDiv"]').handsontable("getInstance");
                    htable.loadData(table.table);

                    changed = true;
                    break;
                default:
                    var ctx_load_funcs_step = obj.ctx_load_funcs_step_gen(
                        obj, load_step, load_funcs_step + 1, ctx);
                    ctx_load_funcs_step();
                    return;
                    break;
                }

                step_cur++;
            }
            setTimeout(ctx_load_func_discr_step, 0);
        }

        return ctx_load_func_discr_step;
    },
    
    ctx_load_funcs_step_gen: function (obj, load_step, step_cur, ctx) {
        function ctx_load_funcs_step() {
            var tables = ctx.tables;
            wrapping4load(obj.pfx + '*', true);

            if (gl_wrapping4load_counter != 0) {
                // console.log("ctx_load_funcs_step: gl_wrapping4load_counter != 0 (" + gl_wrapping4load_counter + ")");
                gl_wrapping4load_counter = 0;
                setTimeout(ctx_load_funcs_step, 0);
                // console.log('retry later');
                return;
            }
            // else {
            //     console.log('ctx_load_funcs_step, advance');
            // }
            if (step_cur < tables.length) {
                if (tables[step_cur].type == 'prob_mass') {
                    var ctx_load_func_cont_step = obj.ctx_load_func_prob_mass_step_gen(
                        obj, load_step, step_cur, 0, ctx);
                    ctx_load_func_cont_step();
                    return;
                }
                else if (tables[step_cur].type == 'discr') {
                    var ctx_load_func_discr_step = obj.ctx_load_func_discr_step_gen(
                        obj, load_step, step_cur, 0, ctx);
                    ctx_load_func_discr_step();
                    return;
                }
                else {
                    console.log('Unknown table type: ' + tables[step_cur].type);
                }
            }
            else {
                // return to ctx_load
                var ctx_load_step = obj.ctx_load_step_gen(obj, load_step + 1, ctx);
                ctx_load_step();
            }
        }
        return ctx_load_funcs_step;
    },
    
    ctx_load_step_gen: function(obj, step_cur, ctx) {

        function ctx_load_step() {
            console.log('step pre');
            wrapping4load(obj.pfx + '*', true);

            if (gl_wrapping4load_counter != 0) {
                // console.log("ctx_load_step: gl_wrapping4load_counter != 0 (" + gl_wrapping4load_counter + ")");
                gl_wrapping4load_counter = 0;
                setTimeout(ctx_load_step, 0);
                // console.log('retry later');
                return;
            }
            // else {
            //     console.log('ctx_load_step: advance');
            // }
            var changed = false;
            while (changed == false) {
                switch(step_cur) {
                case 0:
                    if (obj.o.find('input#functionId').val() != ctx.functionId) {
                        obj.o.find('input#functionId').val(ctx.functionId).change();
                        changed = true;
                    }
                    break;
                case 1:
                    if (obj.o.find('input#assetCategory').val() != ctx.assetCategory) {
                        obj.o.find('input#assetCategory').val(ctx.assetCategory).change();
                        changed = true;
                    }
                    break;
                case 2:
                    if (obj.o.find('select#lossCategory').val() != ctx.lossCategory) {
                        obj.o.find('select#lossCategory').val(ctx.lossCategory).change();
                        changed = true;
                    }
                    break;
                case 3:
                    if (obj.o.find('textarea#functionDescription').val() != ctx.functionDescription) {
                        obj.o.find('textarea#functionDescription').val(ctx.functionDescription);
                        changed = true;
                    }
                    break;
                case 4:
                    obj.o.find('button[name="destroy_table"]').click();
                    changed = true;
                    break;
                case 5:
                    var ctx_load_funcs_step = obj.ctx_load_funcs_step_gen(obj, step_cur, 0, ctx);
                    ctx_load_funcs_step();
                    return;
                    break;
                default:
                    console.log('dewrapping');
                    wrapping4load(obj.pfx + '*', false);
                    obj.is_interactive = true;
                    return;
                    break;
                }

                step_cur++;
            }
            setTimeout(ctx_load_step, 0);
        };
        return ctx_load_step;
    },

    ctx_load: function (obj) {
        if (window.localStorage == undefined) {
            return false;
        }
        var ser = window.localStorage.getItem('gem_ipt_vulnerability');
        if (ser == null)
            return false;

        var ctx = JSON.parse(ser);

        ctx_load_step = obj.ctx_load_step_gen(obj, 0, ctx);

        obj.is_interactive = false;
        ctx_load_step();
    }
    
};

function vf_sh2long(funcType)
{
    if (funcType == "prob_mass")
        return "probability mass function";
    else if (funcType == "discr")
        return "discrete function";
}

/* acceptable values for funcType are "prob_mass" and "discr" */
function vf_updateTable(funcType)
{
    var table = null;
    var colWidth, maxRows;
    var format_name = vf_sh2long(funcType);
    var tab_header = [];

    // Setup the header
    if (funcType == 'prob_mass') {
        tab_header = ['loss ratio', 'probabilities'];
        colWidth = 80;
        maxRows = "Infinity";
    } else if (funcType == 'discr') {
        tab_header = ['IML', 'meanLRs', 'covLRs'];
        colWidth = 80;
        maxRows = "Infinity";
    }
    else {
        return false;
    }
    // Create the table containers, as many as the user wants
    vf_obj.tbl_idx += 1;

    var imls;
    // Imls value needs to be an array for probability mass function functions,
    // and minIML & maxIML for discrete
    if (funcType == 'prob_mass') {
        imls =
            '<label>IML: </label>' +
            '<input name="imls" class="vfsTable" placeholder="imls array" type="text">' +
            '<input name="distribution_select" type="hidden" class="distributionSelect" value="PM" >';
    } else if (funcType == 'discr') {
        imls =
            '<label> Dist: </label>' +
            '<select name="distribution_select" class="vfsTable distributionSelect">' +
                '<option value="LN">LN</option>' +
                '<option value="BT">BT</option>' +
            '</select><br>';
    }

    // Create the fragility function set (vfs)
    vf_obj.o.find('[name="tables"]').append(
        '<div id="table'+vf_obj.tbl_idx+'" class="tables_gid table'+vf_obj.tbl_idx+'_id'+
          ' vfsTableDiv panel panel-default" data-gem-func-type="'+ funcType + '">' +
          '<strong class="vfsTitle">' + format_name.toUpperCase() + '</strong><button name="destroy_table" class="destroyTable btn-danger btn">Remove Function</button><br>' +
          '<div class="vfsForm" >' +
            '<label> Id: </label>' +
            '<input name="id" class="vfsTable" type="text"><br>' +
            '<label> IMT: </label>' +
            '<input name="imt" class="imt_id imt vfsTable" type="text" placeholder="PGA"><br>' +
            imls + '<br>' +
            '</div>'+
            '<div style="width: 45%; float: right; align: right;">' +
              '<div name="tableDiv'+vf_obj.tbl_idx+'" class="theVTable" style="width: 100%; height: 100px; overflow: hidden;"></div>' +
            '</div>' +
        '</div>'
    );

    // force bootstrap style
    $('.btn-danger').css({'background-color': '#da4f49'});

    //////////////////////
    /// Table Settings ///
    //////////////////////

    var ht_params = {
        startRows: 3,
        colHeaders: tab_header,
        startCols: tab_header.length,
        colWidths: colWidth,

        maxRows: "Infinity",
        rowHeaders: false,
        contextMenu: true,
    };

    if (funcType == 'prob_mass') {
        ht_params.startRows = 1;

        // this function is a callback called by handsontable during table creation
        // to retrieve cellProperties of each cell
        ht_params.cells = function(r,c, prop) {
            var cellProperties = {};
            if (r===0) cellProperties.readOnly = true;
            return cellProperties;
        };
    }

    vf_obj.o.find('[name="tableDiv'+vf_obj.tbl_idx+'"]').handsontable(ht_params);
    table = vf_obj.o.find('[name="tableDiv'+vf_obj.tbl_idx+'"]').handsontable('getInstance');

    vf_obj.tbl[vf_obj.tbl_idx] = table;

    if (funcType == 'discr') {
        var tbl = table;
        var $box = vf_obj.o.find('[name="tableDiv'+vf_obj.tbl_idx+'"]');

        setTimeout(function() {
            return gem_tableHeightUpdate($box);
        }, 0);

        tbl.addHook('afterCreateRow', function() {
            return gem_tableHeightUpdate($box);
        });

        tbl.addHook('afterRemoveRow', function() {
            return gem_tableHeightUpdate($box);
        });
    }

    vf_obj.o.find('#outputText').empty();
    vf_obj.o.find('#convertBtn').show();

    // use tbl_idx to fix with a closure the idx value inside click and change callbacks
    var tbl_idx = vf_obj.tbl_idx;

    // Logic to remove a table
    vf_obj.o.find('.table' + tbl_idx + '_id [name="destroy_table"]').click(function() {
        if (confirm("Do you really want to remove this function?") == false)
            return;
        vf_obj.o.find('#table' + tbl_idx).remove();
        delete vf_obj.tbl[tbl_idx];
        if (Object.keys(vf_obj.tbl).length == 0) {
            vf_obj.o.find('#convertBtn').hide();
        }
    });

    if (funcType == 'prob_mass') {
        vf_obj.o.find('#table' + vf_obj.tbl_idx + ' [name="imls"]').change(function () {
            var el = row_split(this.value);
            var cols_cur, cols_n = el.length + 1;
            var table;

            table = vf_obj.o.find('[name="tableDiv'+tbl_idx+'"]').handsontable('getInstance');

            cols_cur = table.countCols();

            var colHeader = ['loss ratio'];
            for (var i = 1 ; i < cols_n ; i++) {
                colHeader[i] = el[i-1];
            }

            // increment columns number
            if (cols_cur < cols_n) {
                table.alter('insert_col', cols_cur, cols_n - cols_cur);
                table.updateSettings({colHeaders: colHeader, cells: null});
            }
            // reduce columns number
            else {
                table.alter('remove_col', cols_n, cols_cur - cols_n);
                table.updateSettings({colHeaders: colHeader});
            }
        });
    }
}

vf_obj.o.find('#downloadBtn').click(function() {
    sendbackNRML(vf_obj.nrml, 'vf');
});

vf_obj.o.find('#convertBtn').click(function() {
    var tabs_data = {};

    // get the data for each table
    for (var k in vf_obj.tbl) {
        tabs_data[k] = vf_obj.tbl[k].getData();
    }

    // Check for null values
    for (var k in tabs_data) {
        var pfx = '.vf_gid .table'+k+'_id';
        var tab_data = tabs_data[k];

        for (var i = 0; i < tab_data.length; i++) {
            for (var j = 0; j < tab_data[i].length; j++) {
                if (tab_data[i][j] === null || tab_data[i][j].toString().trim() == "") {
                    var funcType = $(pfx).attr('data-gem-func-type');
                    var funcId = $(pfx+' [name="id"]').val();
                    var error_msg = "empty cell detected at coords (" + (i+1) + ", " + (j+1) + ") of " +
                        vf_sh2long(funcType)+ " with ID " + funcId;

                    output_manager('vf', error_msg, null, null);
                    return;
                }
            }
        }
    }

    var functionId = vf_obj.o.find('#functionId').val();
    var assetCategory = vf_obj.o.find('#assetCategory').val();
    var lossCategory = vf_obj.o.find('#lossCategory').val();
    var functionDescription = vf_obj.o.find('#functionDescription').val();


    ////////////////
    // Create vfs //
    ////////////////

    var vulnFunction = '';
    // Create the vfs elements
    for (var k in tabs_data) {
        var vfs = "";
        var tab_data = tabs_data[k];
        var pfx = '.vf_gid .table'+k+'_id';
        var funcType = $(pfx).attr('data-gem-func-type');
        var distSelect = $(pfx+' [name="distribution_select"]').val();
        // Opening vfs tag
        vfs += '\t\t<vulnerabilityFunction id="'+$(pfx+' [name="id"]').val()+
            '" dist="' + distSelect + '">\n';


        if (funcType == 'prob_mass') {
            vfs += '\t\t\t<imls imt="'+$(pfx+' [name="imt"]').val()+'">'+$(pfx+' [name="imls"]').val()+'</imls>\n';
            // Loop through the table rows and create the probabilities tags
            for (var i = 0; i < tab_data.length; i++) {
                // Dynamic vfs tag(s)
                var probs = "";
                for (e = 1 ; e < tab_data[i].length ; e++) {
                    probs += (probs == "" ? "" : " " ) + tab_data[i][e];
                }
                vfs += '\t\t\t<probabilities lr="'+tab_data[i][0]+'">'+probs+'</probabilities>\n';
            }
        }
        else if (funcType == 'discr') {
            var means = "", covs = "", imls = "";
            for (var i = 0; i < tab_data.length; i++) {
                imls  += (imls  == "" ? "" : " " ) + tab_data[i][0];
                means += (means == "" ? "" : " " ) + tab_data[i][1];
                covs  += (covs  == "" ? "" : " " ) + tab_data[i][2];
            }
            vfs += '\t\t\t<imls imt="'+$(pfx+' [name="imt"]').val()+'">' + imls + '</imls>\n';
            vfs += '\t\t\t<meanLRs>' + means + '</meanLRs>\n';
            vfs += '\t\t\t<covLRs>' + covs + '</covLRs>\n';
        }

        // Closing vfs tags
        vfs += '\t\t</vulnerabilityFunction>\n';
        vulnFunction += vfs;
    }

    // Create a NRML element
    var nrml =
        '<?xml version="1.0" encoding="UTF-8"?> \n' +
        '<nrml xmlns="http://openquake.org/xmlns/nrml/0.5"> \n' +
            '\t<vulnerabilityModel id="' + functionId + '" assetCategory="'+ assetCategory + '" lossCategory="'+lossCategory+'"> \n' +
                '\t\t<description>' + functionDescription + '</description> \n' +
                vulnFunction +
            '\t</vulnerabilityModel> \n' +
        '</nrml>\n';

    validateAndDisplayNRML(nrml, 'vf', vf_obj);
});

// initialization function
$(document).ready(function (){
    vf_obj.o.find('#outputDiv').hide();

    vf_obj.o.find('#addProbMassFunc').click(function() {
        vf_updateTable("prob_mass");
    });

    vf_obj.o.find('#addDiscreteFunc').click(function() {
        vf_updateTable('discr');
    });
});

